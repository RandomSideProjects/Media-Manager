<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Directory Creator</title>
  <style>
    .poster-wrapper {
      position: relative;
      display: none; /* shown after an image is selected */
      max-height: 80px;
    }
    #posterPreview {
      display: block;
      max-height: 80px;
      border-radius: 6px;
      border: 1px solid #333;
    }
    .poster-change-btn {
      display: inline-block;
      margin-top: 6px;
      padding: 0.3em 0.7em;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      white-space: nowrap;
    }
    .poster-label-stack {
      display: flex;
      flex-direction: column;
      min-width: 110px;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #121212;
      color: #f1f1f1;
      padding: 2em;
      margin: 0;
    }
    .container {
      width: 90%;
      max-width: 650px;
      margin: 2em auto;
      background: #1a1a1a;
      padding: 2.5em;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      text-align: center;
      margin-bottom: 1em;
      color: #f1f1f1;
    }
    .field-group {
      margin-bottom: 1em;
      display: flex;
      flex-direction: column;
      gap: 0.25em;
      width: 100%;
    }
    input[type="text"] {
      width: calc(100% - 0.8em);
      padding: 0.6em;
      margin-top: 0.2em;
      border: 1px solid #444;
      border-radius: 4px;
      background: #2a2a2a;
      color: #f1f1f1;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
    }
    input[type="file"] {
      display: inline-block;
      margin: 0;
      background: #2a2a2a;
      color: #f1f1f1;
      border: 1px solid #444;
      border-radius: 4px;
    }
    button {
      padding: 0.6em 1.2em;
      margin: 0.5em 0.2em;
      border: none;
      background: #007bff;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: background 0.2s, transform 0.1s;
    }
    button:hover {
      background: #0056b3;
    }
    button:active {
      transform: scale(0.98);
    }
    .category {
      background: #2a2a2a;
      color: #f1f1f1;
      padding: 1em;
      margin-bottom: 1em;
      border: 1px solid #333;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    .episodes {
      margin-top: 0.5em;
      padding-left: 1em;
      border-left: 3px solid #007bff;
    }
    .episode {
      border: 1px solid #333;
      padding: 0.5em;
      margin-bottom: 0.5em;
      border-radius: 4px;
      background: #2a2a2a;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
    }
    .ep-error {
      color: #ff4444;
      font-weight: bold;
      margin-top: 0.2em;
    }
    .input-group {
      display: flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 0.5em;
    }
    pre {
      background: #272822;
      color: #f8f8f2;
      padding: 1em;
      overflow: auto;
      border-radius: 6px;
    }
    #output {
      font-size: 2em;
      font-family: Arial, sans-serif !important;
    }
    #confirmModal {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center; justify-content: center;
    }
    #confirmModal .modal-content {
      background: #1a1a1a;
      color: #f1f1f1;
      padding: 1em;
      border-radius: 8px;
      text-align: center;
    }
    #confirmModal button {
      margin: 0.5em;
    }
    .tabs {
      display: flex;
      margin-bottom: 1em;
      border-bottom: 1px solid #444;
      background: #1f1f1f;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    .settings-button {
      position: fixed;
      top: 16px;
      right: 16px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.2em;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10020;
    }
    .settings-button:hover { background: #0056b3; }
    .tab-button {
      background: transparent;
      color: #f1f1f1;
      border: none;
      padding: 0.75em 1.5em;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 1em;
      transition: background 0.2s;
    }
    .tab-button:hover {
      background: #2a2a2a;
    }
    .tab-button.active {
      background: #007bff;
      color: #fff;
      border-bottom-color: #007bff;
    }
    #outputContainer {
      display:flex; 
      align-items:center; 
      gap:0.5em;
      width: 100%;
      background: #1f1f1f;
      padding: 1em;
      border-radius: 6px;
      margin-top: 1em;
      justify-content: center;
    }
    /* Server status badge */
    #serverStatusBox {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: #1a1a1a;
      color: #f1f1f1;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 0.6em 0.9em;
      font-size: 0.9rem;
      line-height: 1.2;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      z-index: 9999;
      white-space: pre-line;
      display: none; /* default hidden until success */
    }
    /* Server check loading box */
    #serverCheckBox {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a1a;
      color: #f1f1f1;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 1em 1.25em;
      display: none; /* shown while checking */
      align-items: center;
      gap: 0.75em;
      box-shadow: 0 12px 30px rgba(0,0,0,0.5);
      z-index: 10000;
    }
    #serverCheckBox .serverCheckText {
      white-space: pre-line;
      font-weight: 600;
      line-height: 1.3;
    }
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255,255,255,0.25);
      border-top-color: #5ab8ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      flex: 0 0 24px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  <style>
    /* ===== Upload Settings (injected) ===== */
    .mm-settings-fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 10010;
      padding: 0.6em 0.9em;
      border-radius: 50px;
      background: #007bff;
      color: #fff;
      border: none;
      box-shadow: 0 4px 14px rgba(0,0,0,0.4);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .3px;
    }
    .mm-settings-fab:hover { background:#0056b3; }

    .mm-settings-panel {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center; z-index: 10011;
      background: rgba(0,0,0,0.7);
      font-family: inherit; color: #f1f1f1;
    }
    .mm-settings-panel .mm-card {
      width: 92%; max-width: 520px; background: #1a1a1a; color: #f1f1f1;
      border-radius: 12px; padding: 16px; box-shadow: 0 10px 24px rgba(0,0,0,0.55);
    }
    .mm-settings-row { display:flex; align-items:center; gap:.5em; margin:.5em 0; }
    .mm-toggle { display:flex; align-items:center; gap:.5em; cursor:pointer; }
    .mm-input { width:100%; padding:.6em; border-radius:6px; border:1px solid #444; background:#2a2a2a; color:#f1f1f1; }
    .mm-actions { display:flex; gap:.5em; justify-content:flex-end; margin-top: 10px; }
    .mm-btn { padding:.55em 1em; border:none; border-radius:8px; cursor:pointer; }
    .mm-btn.primary { background:#007bff; color:#fff; }
    .mm-btn.primary:hover { background:#0056b3; }
    .mm-btn.ghost { background:#2a2a2a; color:#f1f1f1; border:1px solid #444; }
  </style>
</head>
<body>
  <div class="container">
    <div class="tabs">
      <button id="homeTabBtn" class="tab-button">Home</button>
      <button id="createTabBtn" class="tab-button active">Create</button>
      <button id="editTabBtn" class="tab-button">Edit</button>
    </div>
    <button id="mmUploadSettingsBtn" class="settings-button">⚙️</button>
    <h1>Directory Creator</h1>
    <div class="field-group" id="loadUrlContainer">
      <label for="loadUrl">Load Directory URL:</label><br/>
      <input type="text" id="loadUrl" placeholder="Enter JSON URL"/>
      <button id="loadBtn" type="button">Load</button>
    </div>
    <div class="field-group">
      <label for="dirTitle">Directory Title:</label><br/>
      <input type="text" id="dirTitle" placeholder="Series Title"/>
      <div class="input-group" id="posterGroup" style="align-items:flex-start; gap:0.75em; margin-top:0.5em;">
        <div class="poster-label-stack">
          <label for="posterInput">Poster image:</label>
          <button id="posterChangeBtn" type="button" class="poster-change-btn" style="display:none;">Change Poster?</button>
        </div>
        <input type="file" id="posterInput" accept="image/*">
        <div id="posterWrapper" class="poster-wrapper" style="display:none;">
          <img id="posterPreview" alt="Poster preview" />
        </div>
      </div>
      <div id="posterStatus" style="font-size:0.9em; color:#9ecbff; display:none; margin-top:0.25em;">
        Uploading image…
        <progress id="posterProgress" max="100" value="0" style="vertical-align:middle; width:160px; margin-left:0.5em;"></progress>
      </div>
    </div>
    <div id="categories"></div>
    <button id="addCategory">Add Category</button>
    <div class="field-group" style="display:flex; align-items:center; gap:0.5em; margin-top:1em;">
      <label id="folderSelectBtn" for="folderInput" class="tab-button" style="margin:0;">Select Folder</label>
      <input type="file" id="folderInput" webkitdirectory multiple style="display:none;">
    </div>
    <div id="outputContainer" style="display:flex; align-items:center; gap:0.5em;">
      <pre id="output"><a id="outputLink" href="#" target="_blank"></a></pre>
    </div>
  </div>

  <div id="confirmModal">
    <div class="modal-content">
      <p>Are you sure you want to delete this category?</p>
      <button id="confirmYes">Yes</button>
      <button id="confirmNo">Cancel</button>
    </div>
  </div>

  <script>
    const STATUS_URL = 'https://files.catbox.moe/6gkiu0.png';

    // === Global block flags for server failure ===
    window.MM_BLOCKED = false; // true when server check fails until user continues
    window.MM_POLL_TIMER = null; // holds auto-upload polling interval id

    function showHostFailure(container, codeText) {
      // Create a full-screen overlay instead of replacing the container content
      let overlay = document.getElementById('serverFailOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'serverFailOverlay';
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = 'rgba(0,0,0,0.85)';
        overlay.style.zIndex = '10050';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.innerHTML = `
          <div style="background:#1a1a1a; color:#f1f1f1; border:1px solid #333; border-radius:12px; padding:18px 22px; max-width:720px; width:92%; text-align:center; box-shadow:0 16px 40px rgba(0,0,0,.6);">
            <div style="font-weight:800; font-size:1.25rem; line-height:1.35; white-space:pre-line;">
              Unfortunately, our public source host is currently unavailable.\nPlease try again.
            </div>
            <div style="margin-top:10px;">
              <code style="background:#000; display:inline-block; padding:0.6em 0.8em; border-radius:8px; color:#fff;">HTTP Code : ${codeText}</code>
            </div>
            <div style="margin-top:14px; display:flex; gap:10px; justify-content:center;">
              <button id="serverContinueBtn" style="padding:8px 14px; border:none; border-radius:8px; background:#007bff; color:#fff; cursor:pointer;">Continue</button>
            </div>
          </div>`;
        document.body.appendChild(overlay);
      } else {
        const codeEl = overlay.querySelector('code');
        if (codeEl) codeEl.textContent = `HTTP Code : ${codeText}`;
      }

      // Block functionality until user continues
      window.MM_BLOCKED = true;

      // Wire the Continue button once
      const btn = document.getElementById('serverContinueBtn');
      if (btn && !btn.dataset.bound) {
        btn.dataset.bound = '1';
        btn.addEventListener('click', () => {
          window.MM_BLOCKED = false;
          // Start polling if defined and not already running
          if (typeof startAutoUploadPolling === 'function' && !window.MM_POLL_TIMER) {
            startAutoUploadPolling();
          }
          // Hide the overlay
          const ov = document.getElementById('serverFailOverlay');
          if (ov) ov.remove();
        });
      }
    }

    async function checkHostAndLoadCreator() {
      const container = document.querySelector('.container') || document.body;
      // Create status box (hidden until success)
      let statusBox = document.getElementById('serverStatusBox');
      if (!statusBox) {
        statusBox = document.createElement('div');
        statusBox.id = 'serverStatusBox';
        document.body.appendChild(statusBox);
      }

      // Create loading box
      let checkBox = document.getElementById('serverCheckBox');
      if (!checkBox) {
        checkBox = document.createElement('div');
        checkBox.id = 'serverCheckBox';
        checkBox.innerHTML = `
          <div class="spinner" aria-hidden="true"></div>
          <div class="serverCheckText" id="serverCheckText">Checking if server is responsive\nTime Elapsed : 00:00</div>
        `;
        document.body.appendChild(checkBox);
      }
      const checkText = document.getElementById('serverCheckText');
      checkBox.style.display = 'flex';

      const started = Date.now();
      const fmt = (ms) => {
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
      };
      const tick = () => {
        if (checkText) checkText.textContent = `Checking if server is responsive\nTime Elapsed : ${fmt(Date.now() - started)}`;
      };
      tick();
      const timer = setInterval(tick, 250);

      const stop = () => {
        clearInterval(timer);
        if (checkBox) checkBox.remove();
      };

      let resp;
      try {
        resp = await fetch(STATUS_URL, { cache: 'no-store' });
      } catch (err) {
        stop();
        showHostFailure(container, err && err.message ? err.message : 'Network error');
        return;
      }

      if (!resp || !resp.ok) {
        const codeText = resp ? `${resp.status} ${resp.statusText || ''}`.trim() : 'Unknown error';
        stop();
        showHostFailure(container, codeText);
        return;
      }

      // Success path: show status code box and continue
      stop();
      statusBox.textContent = `Server status code\n${resp.status}`;
      statusBox.style.display = 'block';
    }

    // Run the check as soon as the script loads
    checkHostAndLoadCreator();
    async function uploadToCatbox(file) {
      const form = new FormData();
      form.append('reqtype', 'fileupload');
      form.append('fileToUpload', file);

      // Pull current settings; anonymous defaults to true
      let st = { anonymous: true, userhash: '' };
      try { st = JSON.parse(localStorage.getItem('mm_upload_settings')||'{}') || st; } catch {}
      const isAnon = (typeof st.anonymous === 'boolean') ? st.anonymous : true;
      const effectiveUserhash = ((st.userhash || '').trim()) || '2cdcc7754c86c2871ed2bde9d';
      if (!isAnon) {
        form.append('userhash', effectiveUserhash);
      }

      const res = await fetch('https://catbox.moe/user/api.php', {
        method: 'POST',
        body: form
      });
      if (!res.ok) throw new Error('Upload error');
      return await res.text();
    }

    function uploadToCatboxWithProgress(file, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', 'https://catbox.moe/user/api.php');
        const form = new FormData();
        form.append('reqtype', 'fileupload');
        form.append('fileToUpload', file);
        // Pull current settings; anonymous defaults to true
        let st = { anonymous: true, userhash: '' };
        try { st = JSON.parse(localStorage.getItem('mm_upload_settings')||'{}') || st; } catch {}
        const isAnon = (typeof st.anonymous === 'boolean') ? st.anonymous : true;
        const effectiveUserhash = ((st.userhash || '').trim()) || '2cdcc7754c86c2871ed2bde9d';
        if (!isAnon) {
          form.append('userhash', effectiveUserhash);
        }

        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percent = (e.loaded / e.total) * 100;
            try { onProgress && onProgress(percent); } catch {}
          }
        });

        xhr.onload = () => {
          const ok = xhr.status >= 200 && xhr.status < 300;
          if (ok && typeof xhr.responseText === 'string' && xhr.responseText.trim()) {
            resolve(xhr.responseText.trim());
          } else {
            const err = new Error('Upload error: ' + xhr.status);
            err.status = xhr.status;
            reject(err);
          }
        };

        xhr.onerror = () => {
          const err = new Error('Network error');
          err.status = 0;
          reject(err);
        };

        xhr.send(form);
      });
    }

    const categoriesEl = document.getElementById('categories');
    const posterInput = document.getElementById('posterInput');
    const posterPreview = document.getElementById('posterPreview');
    const posterStatus = document.getElementById('posterStatus');
    const posterProgress = document.getElementById('posterProgress');
    let posterImageUrl = '';
    const posterWrapper = document.getElementById('posterWrapper');
    const posterChangeBtn = document.getElementById('posterChangeBtn');
    if (posterInput) {
      posterInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // Quick local preview
        try {
          const localUrl = URL.createObjectURL(file);
          posterPreview.src = localUrl;
          if (posterWrapper) posterWrapper.style.display = 'inline-block';
          if (posterInput) posterInput.style.display = 'none';
        } catch {}
        if (posterChangeBtn) posterChangeBtn.style.display = 'inline-block';
        // Show uploading UI
        if (posterStatus) posterStatus.style.display = 'inline-block';
        if (posterProgress) posterProgress.value = 0;
        try {
          const url = await uploadToCatboxWithProgress(file, pct => {
            if (posterProgress) posterProgress.value = pct;
          });
          posterImageUrl = (url || '').trim();
          if (posterStatus) posterStatus.style.display = 'none';
        } catch (err) {
          if (posterStatus) {
            posterStatus.style.display = 'inline-block';
            posterStatus.style.color = '#ff6b6b';
            posterStatus.textContent = 'Image upload failed';
          }
          posterImageUrl = '';
          if (posterChangeBtn) posterChangeBtn.style.display = 'none';
        }
      });
    }
    if (posterChangeBtn) {
      posterChangeBtn.addEventListener('click', () => {
        if (posterWrapper) posterWrapper.style.display = 'none';
        if (posterInput) {
          posterInput.style.display = 'inline-block';
          posterInput.value = '';
          posterInput.focus();
        }
        if (posterChangeBtn) posterChangeBtn.style.display = 'none';
        posterImageUrl = '';
        if (posterPreview) posterPreview.src = '';
      });
    }
    const addCategoryBtn = document.getElementById('addCategory');
    const outputEl = document.getElementById('output');
    const loadUrlInput = document.getElementById('loadUrl');
    const loadBtn = document.getElementById('loadBtn');
    const createTabBtn = document.getElementById('createTabBtn');
    const editTabBtn = document.getElementById('editTabBtn');
    const loadUrlContainer = document.getElementById('loadUrlContainer');
    const homeTabBtn = document.getElementById('homeTabBtn');
    const folderInput = document.getElementById('folderInput');
    let isFolderUploading = false;
    const UPLOAD_CONCURRENCY = 2; // conservative to avoid 412 from server under load
    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    // Import a single folder as the next season
    folderInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files);
      if (!files.length) return;
      isFolderUploading = true;
      // Reset input to allow re-selection
      folderInput.value = '';
      // Determine next season number
      const seasonNum = categoriesEl.children.length + 1;
      // Create category block
      addCategory({ category: `Season ${seasonNum}`, episodes: [] });
      const catDiv = categoriesEl.lastElementChild;
      const episodesDiv = catDiv.querySelector('.episodes');
      // Prepare files with episode numbers (fallback to folder order if no E# found)
      const filesInSeason = files.map((file, idx) => {
        const name = file.webkitRelativePath.split('/').pop();
        const m = name.match(/E0?(\d{1,2})/i);
        // Use matched number or fallback to original order (idx+1)
        const epNum = m ? parseInt(m[1], 10) : idx + 1;
        return { file, epNum };
      }).sort((a, b) => a.epNum - b.epNum);
      // Create overlay UI
      const folderOverlay = document.createElement('div');
      folderOverlay.id = 'folderUploadOverlay';
      folderOverlay.style.position = 'fixed';
      folderOverlay.style.inset = '0';
      folderOverlay.style.background = 'rgba(0,0,0,0.85)';
      folderOverlay.style.display = 'flex';
      folderOverlay.style.alignItems = 'center';
      folderOverlay.style.justifyContent = 'center';
      folderOverlay.style.zIndex = '10000';
      folderOverlay.innerHTML = `
        <div style="background:#1a1a1a; padding:1em; border-radius:8px; width:90%; max-width:700px; color:#f1f1f1; font-family:inherit;">
          <h2 style="margin-top:0; font-size:1.4em;">Uploading Folder</h2>
          <div id="folderUploadList" style="display:grid; gap:8px; max-height:50vh; overflow:auto;"></div>
          <div style="margin-top:0.75em; display:flex; justify-content:space-between; align-items:center;">
            <div id="folderUploadSummary" style="font-size:0.9em;">0 / 0 completed</div>
          </div>
        </div>
      `;
      document.body.appendChild(folderOverlay);
      const folderUploadList = folderOverlay.querySelector('#folderUploadList');
      const folderUploadSummary = folderOverlay.querySelector('#folderUploadSummary');
      // Show total immediately
      folderUploadSummary.textContent = `0 / ${filesInSeason.length} completed`;

      // Build tasks but run them with limited concurrency
      const taskFns = [];
      const maxAttempts = 5;
      let completedCount = 0;

      filesInSeason.forEach(({ file, epNum }) => {
        // Add episode UI stub
        addEpisode(episodesDiv, { title: `Episode ${epNum}`, src: '' });
        const epDiv = episodesDiv.lastElementChild;
        const inputs = epDiv.querySelectorAll('input[type="text"]');
        const epSrcInput = inputs[1];
        const epError = epDiv.querySelector('.ep-error');
        epError.textContent = '';

        // Overlay progress row
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '0.75em';
        row.style.padding = '6px 8px';
        row.style.background = '#222';
        row.style.borderRadius = '6px';
        row.style.fontSize = '0.9em';
        const label = document.createElement('div');
        label.textContent = `Episode ${epNum}`;
        label.style.flex = '1';
        const status = document.createElement('div');
        status.textContent = 'Queued';
        status.style.minWidth = '110px';
        const progressWrapper = document.createElement('div');
        progressWrapper.style.flex = '2';
        const prog = document.createElement('progress');
        prog.max = 100; prog.value = 0; prog.style.width = '100%';
        progressWrapper.appendChild(prog);
        row.appendChild(label);
        row.appendChild(progressWrapper);
        row.appendChild(status);
        folderUploadList.appendChild(row);

        const fn = async () => {
          for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            status.textContent = (attempt === 1) ? 'Uploading' : `Retry ${attempt} of ${maxAttempts}`;
            prog.value = 0;
            try {
              const url = await uploadToCatboxWithProgress(file, pct => { prog.value = pct; });
              epSrcInput.value = url;
              epError.textContent = '';
              status.textContent = 'Done';
              status.style.color = '#6ec1e4';
              prog.value = 100;
              completedCount++;
              folderUploadSummary.textContent = `${completedCount} / ${filesInSeason.length} completed`;
              return;
            } catch (err) {
              // Backoff for retryable statuses (412, 429, 503) or generic failures
              if (attempt < maxAttempts) {
                const base = 800 * Math.pow(2, attempt - 1); // 0.8s, 1.6s, 3.2s, ...
                const jitter = base * (0.3 + Math.random() * 0.4); // 30–70% jitter
                await sleep(base + jitter);
                continue;
              }
              status.textContent = 'Failed';
              status.style.color = '#ff4444';
              epError.innerHTML = '<span style="color:red">Upload failed</span>';
              return;
            }
          }
        };
        taskFns.push(fn);
      });

      // Run with limited concurrency
      const runWithConcurrency = async (fns, limit) => {
        let idx = 0;
        const workers = Array.from({ length: Math.min(limit, fns.length) }, async () => {
          while (idx < fns.length) {
            const current = fns[idx++];
            await current();
          }
        });
        await Promise.all(workers);
      };

      try {
        await runWithConcurrency(taskFns, UPLOAD_CONCURRENCY);
      } finally {
        isFolderUploading = false;
        if (folderOverlay) folderOverlay.remove();
      }
    });
    // Start in Create mode
    loadUrlContainer.style.display = 'none';

    let isFullUrl = false;
    let directoryCode = '';
    const outputLink = document.getElementById('outputLink');


    // Auto-upload current configuration (with LatestTime)
    async function autoUploadFromContent(contentObj) {
      const payload = { ...contentObj, LatestTime: new Date().toISOString() };
      const jsonString = JSON.stringify(payload, null, 2);
      try {
        const blob = new Blob([jsonString], { type: 'application/json' });
        const file = new File([blob], 'directory.json', { type: 'application/json' });
        const url = await uploadToCatbox(file);
        directoryCode = url.replace(/^https:\/\/files\.catbox\.moe\//, '').replace(/\.json$/, '').trim();
        updateOutput();
      } catch (err) {
        outputEl.textContent = 'Failed to auto-upload: ' + err.message;
      }
    }
    // Auto-upload when data changes, every 500ms (starts only when not blocked)
    function startAutoUploadPolling() {
      if (window.MM_POLL_TIMER) return; // already started
      if (window.MM_BLOCKED) return;    // don't start when blocked
      let lastContent = null; // JSON string of title/Image/categories only
      window.MM_POLL_TIMER = setInterval(async () => {
        if (window.MM_BLOCKED) return; // hard stop while blocked
        if (isFolderUploading) return;
        const titleEl = document.getElementById('dirTitle');
        if (!titleEl) return; // elements not ready
        const titleVal = titleEl.value.trim();
        const cats = [];
        document.querySelectorAll('.category').forEach(cat => {
          const input = cat.querySelector('label input');
          const catTitle = input ? input.value.trim() : '';
          const eps = [];
          cat.querySelectorAll('.episode').forEach(epDiv => {
            const inputs = epDiv.querySelectorAll('input[type="text"]');
            const t = inputs[0] ? inputs[0].value.trim() : '';
            const s = inputs[1] ? inputs[1].value.trim() : '';
            if (t && s) eps.push({ title: t, src: s });
          });
          if (catTitle) cats.push({ category: catTitle, episodes: eps });
        });
        const imageField = posterImageUrl || 'N/A';
        const contentOnly = { title: titleVal, Image: imageField, categories: cats };
        const contentStr = JSON.stringify(contentOnly);
        if (contentStr !== lastContent) {
          lastContent = contentStr;
          try { await autoUploadFromContent(contentOnly); } catch (err) { console.error('Auto-upload error:', err); }
        }
      }, 500);
    }

    // Start polling only if not blocked
    if (!window.MM_BLOCKED) {
      startAutoUploadPolling();
    }

    // Add a new category block
    function addCategory(data) {
      // Determine category index
      const categoryIndex = categoriesEl.children.length + 1;

      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'category';

      categoryDiv.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        confirmModal.style.display = 'flex';
        pendingRemoval = { type: 'category', elem: categoryDiv };
      });

      const titleLabel = document.createElement('label');
      titleLabel.textContent = 'Category Title:';
      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.placeholder = `Season ${categoryIndex}`;
      if (data && data.category) {
        titleInput.value = data.category;
      } else {
        titleInput.value = `Season ${categoryIndex}`;
      }
      titleLabel.appendChild(document.createElement('br'));
      titleLabel.appendChild(titleInput);

      const episodesDiv = document.createElement('div');
      episodesDiv.className = 'episodes';

      const addEpBtn = document.createElement('button');
      addEpBtn.type = 'button';
      addEpBtn.textContent = 'Add Episode';
      addEpBtn.addEventListener('click', () => addEpisode(episodesDiv));

      categoryDiv.appendChild(titleLabel);
      categoryDiv.appendChild(episodesDiv);
      categoryDiv.appendChild(addEpBtn);

      categoriesEl.appendChild(categoryDiv);

      // autoUpload now handled by polling loop

      if (data && data.episodes) {
        data.episodes.forEach(ep => addEpisode(episodesDiv, ep));
      }
    }

    // Add a new episode block within a category
    function addEpisode(container, data) {
      // Determine episode index within this category
      const episodeIndex = container.querySelectorAll('.episode').length + 1;

      const epDiv = document.createElement('div');
      epDiv.className = 'episode';

      epDiv.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        epDiv.remove();
        // autoUpload now handled by polling loop
      });

      const epTitle = document.createElement('input');
      epTitle.type = 'text';
      epTitle.placeholder = 'Episode Title';
      if (data && data.title) {
        epTitle.value = data.title;
      } else {
        epTitle.value = `Episode ${episodeIndex}`;
      }

      const epSrc = document.createElement('input');
      epSrc.type = 'text';
      epSrc.placeholder = 'MP4 or WebM URL';
      if (data && data.src) epSrc.value = data.src;

      const epFile = document.createElement('input');
      epFile.type = 'file';
      epFile.accept = '.mp4, .webm';

      const epError = document.createElement('div');
      epError.className = 'ep-error';

      epFile.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // Clear previous messages
        epError.textContent = '';
        if (file.size > 200 * 1024 * 1024) {
          epError.innerHTML = '<span style="color:#f1f1f1">Our built-in uploader only supports 200 MB. Please try again with a smaller size.</span>';
          return;
        }
        // Primary upload with progress bar
        epSrc.value = '';
        epError.innerHTML = ''; // clear previous messages
        const uploadingMsg = document.createElement('span');
        uploadingMsg.style.color = 'blue';
        uploadingMsg.textContent = 'Uploading';
        epError.appendChild(uploadingMsg);
        const progressBar = document.createElement('progress');
        progressBar.max = 100;
        progressBar.value = 0;
        progressBar.style.marginLeft = '0.5em';
        epError.appendChild(progressBar);
        try {
          const url = await uploadToCatboxWithProgress(file, (percent) => {
            progressBar.value = percent;
          });
          epSrc.value = url;
          epError.textContent = '';
        } catch (err) {
          epError.innerHTML = '<span style="color:red">Upload failed</span>';
          epSrc.value = '';
        }
      });

      epDiv.appendChild(epTitle);

      // URL or File upload group
      const inputGroup = document.createElement('div');
      inputGroup.className = 'input-group';
      inputGroup.appendChild(epSrc);
      const orSpan = document.createElement('span');
      orSpan.textContent = 'or';
      inputGroup.appendChild(orSpan);
      inputGroup.appendChild(epFile);
      epDiv.appendChild(inputGroup);

      epDiv.appendChild(epError);
      container.appendChild(epDiv);

      // autoUpload now handled by polling loop
    }

    async function loadDirectory() {
      const url = loadUrlInput.value.trim();
      if (!url) return;
      try {
        const res = await fetch(url);
        const json = await res.json();
        // Set poster from JSON if present
        posterImageUrl = (json.Image && json.Image !== 'N/A') ? json.Image : '';
        if (posterImageUrl) {
          posterPreview.src = posterImageUrl;
          if (posterWrapper) posterWrapper.style.display = 'inline-block';
          if (posterInput) posterInput.style.display = 'none';
        } else {
          posterPreview.src = '';
          if (posterWrapper) posterWrapper.style.display = 'none';
          if (posterInput) posterInput.style.display = 'inline-block';
        }
        if (posterChangeBtn) posterChangeBtn.style.display = posterImageUrl ? 'inline-block' : 'none';
        if (posterStatus) { posterStatus.style.display = 'none'; posterStatus.style.color = '#9ecbff'; posterStatus.textContent = 'Uploading image…'; }
        // Clear existing
        document.getElementById('dirTitle').value = json.title || '';
        categoriesEl.innerHTML = '';
        json.categories.forEach(cat => addCategory(cat));
        // Set lastContent so loading doesn't immediately trigger upload
        const contentOnly = { title: json.title || '', Image: posterImageUrl || 'N/A', categories: json.categories || [] };
        lastContent = JSON.stringify(contentOnly);
      } catch (err) {
        outputEl.textContent = 'Failed to load: ' + err.message;
      }
    }
    loadBtn.addEventListener('click', loadDirectory);

    // Button handlers
    addCategoryBtn.addEventListener('click', () => addCategory());

    function updateOutput() {
      if (!directoryCode) {
        outputLink.textContent = '';
        outputLink.href = '#';
        return;
      }
      if (isFullUrl) {
        const full = `https://files.catbox.moe/${directoryCode}.json`;
        outputLink.textContent = full;
        outputLink.href = full;
      } else {
        outputLink.textContent = directoryCode;
        outputLink.href = `https://randomsideprojects.github.io/Media-Manager/index.html?source=${directoryCode}`;
      }
    }

    const outputContainer = document.getElementById('outputContainer');
    outputContainer.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      isFullUrl = !isFullUrl;
      updateOutput();
    });

    createTabBtn.addEventListener('click', () => {
      createTabBtn.classList.add('active');
      editTabBtn.classList.remove('active');
      loadUrlContainer.style.display = 'none';
      // Clear all inputs and output
      document.getElementById('dirTitle').value = '';
      categoriesEl.innerHTML = '';
      directoryCode = '';
      updateOutput();
      posterImageUrl = '';
      if (posterPreview) { posterPreview.src = ''; }
      if (posterWrapper) posterWrapper.style.display = 'none';
      if (posterInput) { posterInput.value = ''; posterInput.style.display = 'inline-block'; }
      if (posterStatus) { posterStatus.style.display = 'none'; posterStatus.style.color = '#9ecbff'; posterStatus.textContent = 'Uploading image…'; }
      if (posterChangeBtn) posterChangeBtn.style.display = 'none';
    });
    editTabBtn.addEventListener('click', () => {
      editTabBtn.classList.add('active');
      createTabBtn.classList.remove('active');
      loadUrlContainer.style.display = 'flex';
      document.getElementById('dirTitle').value = '';
      categoriesEl.innerHTML = '';
      directoryCode = '';
      updateOutput();
      posterImageUrl = '';
      if (posterPreview) { posterPreview.src = ''; }
      if (posterWrapper) posterWrapper.style.display = 'none';
      if (posterInput) { posterInput.value = ''; posterInput.style.display = 'inline-block'; }
      if (posterStatus) { posterStatus.style.display = 'none'; posterStatus.style.color = '#9ecbff'; posterStatus.textContent = 'Uploading image…'; }
      if (posterChangeBtn) posterChangeBtn.style.display = 'none';
    });
    homeTabBtn.addEventListener('click', () => {
      window.location.href = './index.html';
    });

    // Auto-upload now handled by polling loop; no need for input event listeners

    // --- Pomf.cat uploader script block ---
    // Example usage:
    //   uploadToPomf(file, { anonymous: false }, userhash, apiKey)
    // Returns a Promise for the uploaded file URL
    function uploadToPomf(file, settings = {}, effectiveUserhash, POMF_API_KEY) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', 'https://a.pomf.cat/upload.php');
        xhr.setRequestHeader('api-key', POMF_API_KEY);
        // Only include userhash if anonymous is false
        if (settings.anonymous === false) {
          xhr.setRequestHeader('userhash', effectiveUserhash);
        }
        const form = new FormData();
        form.append('files[]', file);
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const resp = JSON.parse(xhr.responseText);
              if (resp.success && resp.files && resp.files[0] && resp.files[0].url) {
                resolve(resp.files[0].url);
              } else {
                reject(new Error('Upload error'));
              }
            } catch (e) {
              reject(new Error('Invalid server response'));
            }
          } else {
            reject(new Error('Upload error: ' + xhr.status));
          }
        };
        xhr.onerror = function () {
          reject(new Error('Network error'));
        };
        xhr.send(form);
      });
    }

    const confirmModal = document.getElementById('confirmModal');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    let pendingRemoval = null;
    confirmYes.addEventListener('click', () => {
      if (pendingRemoval && pendingRemoval.type === 'category') {
        pendingRemoval.elem.remove();
        // autoUpload now handled by polling loop
      }
      confirmModal.style.display = 'none';
      pendingRemoval = null;
    });
    confirmNo.addEventListener('click', () => {
      confirmModal.style.display = 'none';
      pendingRemoval = null;
    });


    // Local JSON download on A/Z keypress
    function buildLocalDirectoryJSON() {
      const title = document.getElementById('dirTitle').value.trim();
      const categories = [];
      document.querySelectorAll('.category').forEach(cat => {
        const catTitle = cat.querySelector('input[type="text"]').value.trim();
        const episodes = [];
        cat.querySelectorAll('.episode').forEach(epDiv => {
          const inputs = epDiv.querySelectorAll('input[type="text"]');
          const t = inputs[0].value.trim();
          const s = inputs[1].value.trim();
          if (t && s) episodes.push({ title: t, src: s });
        });
        if (catTitle) categories.push({ category: catTitle, episodes });
      });
      const imageField = posterImageUrl || 'N/A';
      return { title, Image: imageField, categories, LatestTime: new Date().toISOString() };
    }

    document.addEventListener('keydown', (e) => {
      if (['a', 'z'].includes(e.key.toLowerCase())) {
        if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
        const result = buildLocalDirectoryJSON();
        const jsonString = JSON.stringify(result, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${result.title || 'directory'}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }
    });
  </script>
</body>
  <!-- ===== Upload Settings UI (injected) ===== -->
  <div id="mmUploadSettingsPanel" class="mm-settings-panel" role="dialog" aria-modal="true">
    <div class="mm-card">
      <h3 style="margin:.2em 0 0.6em 0;">Upload Settings</h3>
      <div class="mm-settings-row">
        <label class="mm-toggle">
          <input type="checkbox" id="mmAnonToggle" checked>
          <span>Anonymous uploads</span>
        </label>
      </div>
      <div id="mmUserhashRow" class="mm-settings-row" style="display:none; flex-direction:column; align-items:stretch;">
        <label for="mmUserhashInput">Userhash (used when Anonymous is off)</label>
        <input id="mmUserhashInput" class="mm-input" type="text" placeholder="Leave blank to use default">
        <small>Default if blank: <code>2cdcc7754c86c2871ed2bde9d</code></small>
      </div>
      <div class="mm-actions">
        <button id="mmSaveUploadSettings" class="mm-btn primary">Save</button>
        <button id="mmCloseUploadSettings" class="mm-btn ghost">Close</button>
      </div>
    </div>
  </div>
  <script>
  (function(){
    // ===== Constants =====
    const POMF_ENDPOINT = 'https://pomf.cat/upload';
    const POMF_API_KEY  = '3e1ba203-5a93-4c18-a7d9-f728e1c98cd6';
    const POMF_MAX_BYTES = 75 * 1024 * 1024; // 75 MB
    const DEFAULT_USERHASH = '2cdcc7754c86c2871ed2bde9d';
    const LS_SETTINGS_KEY = 'mm_upload_settings';

    // ===== Settings state =====
    function loadUploadSettings(){
      try {
        const raw = localStorage.getItem(LS_SETTINGS_KEY);
        if (!raw) return { anonymous: true, userhash: '' };
        const p = JSON.parse(raw);
        return { anonymous: typeof p.anonymous==='boolean' ? p.anonymous : true, userhash: (p.userhash||'').trim() };
      } catch { return { anonymous: true, userhash: '' }; }
    }
    function saveUploadSettings(s){
      localStorage.setItem(LS_SETTINGS_KEY, JSON.stringify({ anonymous: !!s.anonymous, userhash: (s.userhash||'').trim() }));
    }

    // ===== File helpers =====
    function isJsonFile(file){
      const n=(file?.name||'').toLowerCase(); const t=(file?.type||'').toLowerCase();
      return n.endsWith('.json') || t==='application/json';
    }
    function isVideoFile(file){
      const t=(file?.type||'').toLowerCase(); const n=(file?.name||'').toLowerCase();
      return t.startsWith('video/') || /\.(mp4|webm|mkv|mov|avi|m4v)$/i.test(n);
    }
    function shouldUsePomf(file){
      return isVideoFile(file) && file.size <= POMF_MAX_BYTES;
    }

    // ===== pomf.cat uploader (XHR for progress) =====
    function uploadToPomf(file, { onProgress } = {}){
      const settings = loadUploadSettings();
      const effectiveUserhash = (settings.userhash || '').trim() || DEFAULT_USERHASH;
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', POMF_ENDPOINT);
        xhr.setRequestHeader('api-key', POMF_API_KEY);
        if (!settings.anonymous) {
          xhr.setRequestHeader('userhash', effectiveUserhash);
        }
        if (xhr.upload && typeof onProgress === 'function') {
          xhr.upload.onprogress = (evt) => {
            if (evt.lengthComputable) {
              const pct = Math.round((evt.loaded/evt.total)*100);
              try { onProgress(pct, evt.loaded, evt.total); } catch {}
            }
          };
        }
        xhr.onreadystatechange = () => {
          if (xhr.readyState !== 4) return;
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const data = JSON.parse(xhr.responseText || '{}');
              const url = (function(resp){
                if (!resp) return null;
                if (resp.files && Array.isArray(resp.files) && resp.files[0]?.url) return resp.files[0].url;
                if (typeof resp.url === 'string') return resp.url;
                if (typeof resp.file === 'string') return resp.file;
                if (resp.files && Array.isArray(resp.files) && resp.files[0]?.url && !/^https?:\/\//i.test(resp.files[0].url)) {
                  return new URL(resp.files[0].url, 'https://pomf.cat').toString();
                }
                return null;
              })(data);
              if (!url) return reject(new Error('Upload succeeded but no URL returned by pomf.cat.'));
              resolve(url);
            } catch(e) {
              reject(new Error('Upload succeeded but response parse failed: '+e.message));
            }
          } else {
            reject(new Error(`pomf.cat upload failed (${xhr.status})`));
          }
        };
        const fd = new FormData();
        fd.append('file', file, file.name);
        xhr.send(fd);
      });
    }

    // ===== Public API: policy-aware uploader =====
    // Use this helper in your other code: window.mm_uploadFileWithPolicy(file, { onProgress })
    async function mm_uploadFileWithPolicy(file, { onProgress } = {}){
      if (!file) throw new Error('No file provided');
      if (isJsonFile(file)) {
        // NEVER route JSON through pomf
        throw new Error('JSON uploads must use the existing JSON uploader (not pomf.cat).');
      }
      if (shouldUsePomf(file)) {
        return uploadToPomf(file, { onProgress });
      }
      throw new Error('File should be routed to your primary uploader (non-pomf).');
    }

    // Expose globals
    window.mm_uploadFileWithPolicy = mm_uploadFileWithPolicy;
    window.mm_uploadSettings = { load: loadUploadSettings, save: saveUploadSettings };

    // ===== UI wiring =====
    const btn = document.getElementById('mmUploadSettingsBtn');
    const panel = document.getElementById('mmUploadSettingsPanel');
    const anonToggle = document.getElementById('mmAnonToggle');
    const userhashRow = document.getElementById('mmUserhashRow');
    const userhashInput = document.getElementById('mmUserhashInput');
    const saveBtn = document.getElementById('mmSaveUploadSettings');
    const closeBtn = document.getElementById('mmCloseUploadSettings');

    if (btn && panel && anonToggle && userhashRow && userhashInput && saveBtn && closeBtn) {
      const st = loadUploadSettings();
      anonToggle.checked = !!st.anonymous;
      userhashInput.value = st.userhash || '';
      userhashRow.style.display = st.anonymous ? 'none' : '';

      btn.addEventListener('click', () => { panel.style.display = 'flex'; });
      closeBtn.addEventListener('click', () => { panel.style.display = 'none'; });
      panel.addEventListener('click', (e)=>{ if(e.target===panel) panel.style.display='none'; });
      anonToggle.addEventListener('change', () => { userhashRow.style.display = anonToggle.checked ? 'none' : ''; });
      saveBtn.addEventListener('click', () => {
        saveUploadSettings({ anonymous: anonToggle.checked, userhash: userhashInput.value.trim() });
        panel.style.display = 'none';
      });
    }

    // ===== Test JSON sender + 'Q' hotkey =====
    async function mm_sendTestJson() {
      try {
        // snapshot current settings
        const st = loadUploadSettings();
        const effectiveUserhash = (st.userhash || '').trim() || DEFAULT_USERHASH;
        // grab a tiny snapshot of page state (best-effort; tolerate missing els)
        let titleVal = '';
        try { const t = document.getElementById('dirTitle'); titleVal = t ? (t.value || '').trim() : ''; } catch {}
        let categoryCount = 0;
        try { categoryCount = document.querySelectorAll('.category').length; } catch {}

        const payload = {
          _type: 'media-manager-test',
          page: 'creator.html',
          at: new Date().toISOString(),
          settings: {
            anonymous: !!st.anonymous,
            userhash: st.anonymous ? '(ignored: anonymous=true)' : effectiveUserhash
          },
          state: {
            title: titleVal,
            categories: categoryCount
          },
          ua: navigator.userAgent || ''
        };

        const json = JSON.stringify(payload, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const file = new File([blob], `mm_test_${Date.now()}.json`, { type: 'application/json' });

        // Log the intended request details (what we control here)
        console.log('[MM][TestJSON] Preparing request:', {
          endpoint: 'https://catbox.moe/user/api.php',
          method: 'POST',
          headers: { /* FormData boundary handled by XHR; no custom headers for catbox */ },
          formFields: ['reqtype=fileupload', `fileToUpload=${file.name} (${file.size} bytes)`],
          appliedSettings: payload.settings,
          preview: json.slice(0, 400) + (json.length > 400 ? '…' : '')
        });

        // Use the existing XHR uploader (no progress UI needed for test)
        const url = await (window.uploadToCatboxWithProgress ? uploadToCatboxWithProgress(file) : (async () => {
          const fd = new FormData();
          fd.append('reqtype', 'fileupload');
          fd.append('fileToUpload', file);
          const res = await fetch('https://catbox.moe/user/api.php', { method: 'POST', body: fd });
          if (!res.ok) throw new Error('Upload error: ' + res.status);
          return (await res.text()).trim();
        })());

        console.log('[MM][TestJSON] ✅ Uploaded. URL:', url);
        try {
          // show the link in the output area if present
          const outputLink = document.getElementById('outputLink');
          if (outputLink) { outputLink.href = url; outputLink.textContent = url; }
        } catch {}
        return url;
      } catch (err) {
        console.error('[MM][TestJSON] ❌ Failed:', err);
        throw err;
      }
    }

    // Bind global for console access as well
    window.mm_sendTestJson = mm_sendTestJson;

    // Hotkey: press 'Q' (outside inputs) to send test JSON and log request
    document.addEventListener('keydown', (e) => {
      try {
        if ((e.key || '').toLowerCase() !== 'q') return;
        const tag = (e.target && e.target.tagName) || '';
        if (tag === 'INPUT' || tag === 'TEXTAREA') return; // don't hijack typing
        e.preventDefault();
        mm_sendTestJson();
      } catch {}
    });

  })();
  </script>
</html>