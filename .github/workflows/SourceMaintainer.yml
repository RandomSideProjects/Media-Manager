name: Source index Maintainer (DO NOT TOUCH)

on:
  push:
    paths:
      - 'Directorys/Files/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-index:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install image processor (sharp)
        run: npm install sharp@0.33

      - name: Generate Directorys/SourceList.json
        shell: bash
        run: |
          set -euo pipefail
          FILE_DIR="Directorys/Files"
          INDEX_FILE="Directorys/SourceList.json"
          POSTERS_DIR="Directorys/Posters"

          # Create directories if they don't exist
          mkdir -p "$FILE_DIR"
          mkdir -p "$POSTERS_DIR"

          if [[ ! -d "$FILE_DIR" ]]; then
            echo "Directory '$FILE_DIR' does not exist; nothing to index."
            exit 0
          fi

          # Debug information
          echo "Starting indexing process"
          echo "Working directory: $(pwd)"
          echo "File directory exists: $(test -d "$FILE_DIR" && echo "Yes" || echo "No")"
          echo "Posters directory exists: $(test -d "$POSTERS_DIR" && echo "Yes" || echo "No")"

          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const http = require('http');
          const https = require('https');
          const sharp = require('sharp');

          const FILE_DIR = 'Directorys/Files';
          const INDEX_FILE = 'Directorys/SourceList.json';
          const POSTERS_DIR = 'Directorys/Posters';
          
          console.log(`Ensuring directory exists: ${POSTERS_DIR}`);
          if (!fs.existsSync(POSTERS_DIR)) {
            console.log(`Creating directory: ${POSTERS_DIR}`);
            fs.mkdirSync(POSTERS_DIR, { recursive: true });
          }
          console.log(`Posters directory status: ${fs.existsSync(POSTERS_DIR) ? 'exists' : 'missing'}`);

          function safePosterName(title, fallback) {
            const base = String(title || fallback || 'poster')
              .trim()
              .replace(/[\\/:*?"<>|]+/g, ' ')  // remove illegal filename chars
              .replace(/\s+/g, ' ')             // collapse spaces
              .replace(/\./g, '_')              // dots to underscores
              .replace(/\s/g, '_');             // spaces to underscores
            return base || 'poster';
          }

          function fetchBuffer(url, timeoutMs = 12000, maxRedirects = 4) {
            return new Promise((resolve, reject) => {
              const visited = new Set();
              function doRequest(target, redirectsLeft) {
                try {
                  if (visited.has(target)) return reject(new Error('redirect loop'));
                  visited.add(target);
                  const lib = target.startsWith('https:') ? https : http;
                  const req = lib.get(target, {
                    headers: {
                      'User-Agent': 'Mozilla/5.0 (GitHubActions; +https://github.com) RSP-SourceMaintainer',
                      'Accept': 'image/*,*/*;q=0.8',
                      'Connection': 'close'
                    }
                  }, res => {
                    const status = res.statusCode || 0;
                    if ([301,302,303,307,308].includes(status) && res.headers.location && redirectsLeft > 0) {
                      const next = new URL(res.headers.location, target).href;
                      res.resume();
                      return doRequest(next, redirectsLeft - 1);
                    }
                    if (status !== 200) {
                      res.resume();
                      return reject(new Error('HTTP ' + status));
                    }
                    const chunks = [];
                    res.on('data', d => chunks.push(d));
                    res.on('end', () => {
                      const buf = Buffer.concat(chunks);
                      const ct = res.headers['content-type'] || '';
                      resolve({ buf, contentType: ct });
                    });
                  });
                  req.on('error', reject);
                  req.setTimeout(timeoutMs, () => req.destroy(new Error('timeout')));
                } catch (e) { reject(e); }
              }
              // normalize protocol-relative URLs
              if (url && url.startsWith('//')) url = 'https:' + url;
              doRequest(url, maxRedirects);
            });
          }

          function guessMimeFromExt(p) {
            const ext = path.extname(p).toLowerCase();
            switch (ext) {
              case '.jpg':
              case '.jpeg': return 'image/jpeg';
              case '.png': return 'image/png';
              case '.webp': return 'image/webp';
              case '.gif': return 'image/gif';
              default: return 'application/octet-stream';
            }
          }

          (async () => {
            const files = fs.readdirSync(FILE_DIR)
              .filter(f => f.toLowerCase().endsWith('.json') && f.toLowerCase() !== 'exampledir.json');

            const result = { sources: [] };
            console.log(`Found ${files.length} JSON files to process`);

            for (const file of files) {
              try {
                console.log(`Processing file: ${file}`);
                const full = path.join(FILE_DIR, file);
                const raw = fs.readFileSync(full, 'utf8');
                const json = JSON.parse(raw);

                const title = json.title || path.parse(file).name;
                const cats = Array.isArray(json.categories) ? json.categories : [];
                const categoryCount = cats.length;
                let episodeCount = 0;
                for (const c of cats) {
                  if (Array.isArray(c.episodes)) episodeCount += c.episodes.length;
                }

                // Build poster file in repo (WebP, height=512) and reference by path
                let poster = null;
                const imgUrl = (json.Image && json.Image !== 'N/A') ? json.Image : (json.image && json.image !== 'N/A' ? json.image : null);
                if (imgUrl) {
                  console.log(`Processing image for ${title} from ${imgUrl.substring(0, 50)}...`);
                  try {
                    let sourceBuffer;
                    if (imgUrl.startsWith('data:')) {
                      const m = imgUrl.match(/^data:.*?;base64,(.*)$/);
                      if (!m) throw new Error('Unsupported data URI format');
                      sourceBuffer = Buffer.from(m[1], 'base64');
                    } else {
                      console.log(`Fetching image from URL`);
                      const { buf } = await fetchBuffer(imgUrl);
                      sourceBuffer = buf;
                    }
                    
                    console.log(`Processing image with Sharp`);
                    const webpBuf = await sharp(sourceBuffer)
                      .resize({ height: 512 })
                      .webp({ quality: 80 })
                      .toBuffer();

                    const posterName = safePosterName(title, path.parse(file).name) + '.webp';
                    const posterPath = path.join(POSTERS_DIR, posterName);
                    console.log(`Saving poster to: ${posterPath}`);
                    fs.writeFileSync(posterPath, webpBuf);
                    
                    // Verify the file was written
                    if (fs.existsSync(posterPath)) {
                      console.log(`Successfully saved poster: ${posterPath} (${fs.statSync(posterPath).size} bytes)`);
                      poster = `./Posters/${posterName}`;
                    } else {
                      console.error(`Failed to write poster file: ${posterPath}`);
                    }
                  } catch (e) {
                    console.error('Poster build failed for', file, '-', e.message, e.stack);
                  }
                }

                result.sources.push({
                  file,
                  path: `./Files/${file}`,
                  title,
                  poster,           // './Posters/Title.webp' or null
                  categoryCount,
                  episodeCount
                });
              } catch (e) {
                console.error('Skipping', file, e.message, e.stack);
              }
            }

            // Sort by title for stable ordering
            result.sources.sort((a, b) => String(a.title).localeCompare(String(b.title)));

            console.log(`Writing index file: ${INDEX_FILE}`);
            fs.writeFileSync(INDEX_FILE, JSON.stringify(result, null, 2));
            
            // List all generated posters
            console.log("Listing contents of poster directory:");
            if (fs.existsSync(POSTERS_DIR)) {
              const posters = fs.readdirSync(POSTERS_DIR);
              console.log(`Found ${posters.length} posters:`);
              posters.forEach(p => console.log(`- ${p}`));
            } else {
              console.log("Poster directory doesn't exist!");
            }
          })().catch(err => { console.error(err); process.exit(1); });
          NODE

      - name: Debug - List directories
        run: |
          echo "Current directory structure:"
          find Directorys -type d | sort
          echo "Poster files:"
          find Directorys/Posters -type f | sort

      - name: Commit and push changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'chore: update Directorys/SourceList.json and posters'
          file_pattern: |
            Directorys/SourceList.json
            Directorys/Posters/**